# SDK Improvements Notes


---- 
## Separation of Concerns

I would highly suggest making the SDK more modularized and breaking it out into more Maven modules:

- **uof-client** - a client library for the UOF API, abstracts away the complexity of dealing with RabbitMQ
- **uof-model** - generated classes from UOF .xml schemas
- **sports-api-client** - a client library for the Sports API
- **sports-api-model** - generated classes from Sports API .xml schemas
- **sdk-producer** - contains workflow/cache logic for each Producer
- **sdk-interface** - contains interfaces/classes which are exposed to SportRadar customers
- **sdk-core** - core SDK module which simply integrates the other modules together

There is too much coupling of Rabbit/UOF API and SDK Core. When separated out into the modules above, 
their responsibilities are quite clear and can easily be tested independently. 
Also would be far easier to put them together and component test them. 
The SDK could implement a simple listener which would tell it whenever a message has arrived 
from RabbitMQ. 

The **sports-api-client** could be made a common SportRadar library for any Java project wanting to use the Sports API.

Currently, the classes generated from the XML files are part of sdk-core and are regenerated with every build. 
This is not necessary as they rarely change, moving them to their own module would save time.


----
## Simplify SDK Configuration

SDK configuration is massively over-engineered. When adding a single extra config field for the Concurrent Listener, up to 25 source files had to be modified!

SDK configuration can be massively simplified to just 4 classes:
- `SdkConfig` - config object containing strongly typed fields e.g. Set/List/enums (no need for use of Optional)
- `PropertiesSdkConfigLoader` - loads and populates an SdkConfig instance from .properties files
- `YamlSdkConfigLoader` - loads and populates an `SdkConfig` instance from .yaml files
- `SdkConfigLoader` - orchestrator to load config using `PropertiesSdkConfigLoader` and/or `YamlSdkConfigLoader`

Also the currenet `OddsFeedConfiguration` and `SDKInternalConfiguration` class are very flat. Related config fields should be grouped together into classes such as:
- `RabbitMqConfig`
- `SportsApiConfig`
- `ConcurrentListenerConfig`


----
## Eliminate unnecessary/redundant code

### Sports API
There is a huge amount of handcrafted code for using the Sports REST API, but all of this client code can be autogenerated from the [Unified Feed Swagger](https://iodocs.betradar.com/). Even using [Retrofit](https://square.github.io/retrofit/) it's a simple matter of defining Java interfaces.

### Guice
I would look to remove Guice in favour of plain and simple core Java. The SDK codebase is quite schizophrenic in places, some where Guice is used and other places where it's been avoided. Guice causes too much boilerplate and it's just not being used elegantly. For an example of this take a look at the `close()` method in `OddsFeed` - when using a Dependency Injection framework you should never have to reach into it and grab instances to perform actions. 

The use of Guice modules for testing (see `TestingModule` and `SdkTestModule`) really don't help to exercise the code. They rely on mocks and real .xml files and so are very limited in the scenarios which can be tested. There is a real lack of control over what can be tested. 

### Log Replay
The SDK has an **sdk-log-replay** module which I think is unnecessary. 
It's used to playback captured logs locally, and RabbitMQ needs to be running locally in Docker. 
This replay mechanism only exists because of the complete lack of modularisation/testability of 
the SDK. It's a manual process, is time consuming, introduces too much friction, and results 
are completely redundant as soon as the code changes. 
There is also lots of hardcoding all through the SDK around "replay mode" being enabled, 
but in my opinion the SDK should never be aware of such.
We should be able to control what sets of data we send to the SDK in tests so we can
replicate any possible scenario.

### Multithreaded Example
In the **sdk-example** module, there is `MultithreadedMessageListener` and `MultithreadedSessionSetup` which should be removed. This is a very naive implementation of an `OddsFeedListener` setup which isn't at all fit for purpose. It simply moves all event messages onto a single queue and logs them. The Concurrent Listener is a much better alternative and requires no action from customers once it's enabled.


----
## Use of Threads

### Producers and Locking
There are far too many locks in the SDK, and I suspect this is because each Producer shares the same SDK processing pipeline.
Because there are so many shared resources, this has led to massive use of locks in an attempt to prevent one Producer stepping on the toes of another.
But there is no need for most of this.
Each Producer could simply have its own separate pipeline and so this eliminates the needs for most locks as each Producer is isolated from each other.
The pipeline comprises lightweight Java objects anyway, so I see no point having all Producers sharing one.
You could still have shared pools of XML marshallers/unmarshallers and HTTP Clients, and access to these could use locking.

### Bad Locking Practices
The documentation for using locks in Java is quite clear. 
When you take a lock, you should always close the lock in a `finally` block to ensure it is always closed.
This is not being done anywhere and poses a huge risk.
There are also no multithreaded tests which verify these locks enforce the correct behavior.

In developing the Concurrent Listener, I used a simple and powerful technique to use read/write locks.
See the `AtomicReadWrite` class, all you need to do is pass it what you want to be executed
and it takes care of acquiring the lock, executing your code, and then releasing the lock correctly.

For an example, see `TaskLifecycleTracker`. This has unit tests in `TaskLifecycleTrackerTest`,
but also has separate concurrency tests in `TaskLifecycleTrackerConcurrencyTest` to exercise its
locking behaviour with multiple threads. 

### Remove Threads in favour of Executors
In `GeneralModule.providesDedicatedRabbitMqExecutor()`, a pool of 5 threads is created even 
though there are only 4 max channels (Prematch, Live, Virtuals, System). Each thread name is suffixed 
with "-amqp-t-%d". It would be far better to create a dedicated thread for each, and each thread
named Prematch, Live, Virtuals, and System accordingly. This would also make diagnosing logfiles far easier.

There is use of `Thread.sleep()` throughout the SDK for polling. This should ideally be replaced 
with use of a `ScheduledExecutor`.


----
## Testing

### Component Tests
The new Concurrent Listener has a comprehensive set of unit and component tests which verify its behaviour.


&nbsp;
### Integration Tests
The integration tests (see `AbstractSdkIntegrationTest` and its subclasses) are where we are able to start RabbitMQ (using TestContainers), and stub the Sports Api. Then we are in a position to playback test scenarios.

Initially the Sports API was stubbed using WireMock, but has since been changed to an Undertow implementation to give us more control. The WireMock version still exists and you can configure the tests to run using either implementation.

These integration tests could replace all replay code so the **sdk-log-replay** module code could eventually be deleted, as well as any SDK code which relates to the replay mode.


&nbsp;
#### Fixtures
There are test Fixtures which are used to control the SDKs dependencies (Unified Odds Feed and Sports API).

Here is a current list of all test Fixtures:
- `ApiServerStubFixture`
- `OddsFeedConfigurationFixture`
- `OddsFeedFixture`
- `OddsFeedLifecycleFixture`
- `RabbitMqFixture`
- `EnvironmentManagerFixture`
- `AliveHeartbeatFixture`
- `LogReplayFixture`
- `SleepFixture`

Some test Fixture classes are wrapped with Expectation classes to provide a nice fluent way to interact with the Fixtures, and make the tests much more readable and consistent.

When a test is started, the following happens automatically:
- A Bookmaker ID is assigned to the SDK by controlling the response to the `/whoami.xml` API call
- We influence the Producers used by the SDK by controlling the response to the `/producers.xml` API call 

After that, we control what messages are sent from RabbitMQ to play out various scenarios.


&nbsp;
#### Separate Integration Tests into their own Module
Currently the integration tests sit within the **src/main/java** folder of the **sdk-core module**,
and are suffixed with `IT` rather than `Test` so they can be run using the Failsafe Maven plugin
(as opposed to the Surefire plugin which runs unit tests).

When the integration tests are in their own Maven module, they would then have to pull in the sdk-core .jar
and this would ensure we are testing against the actual production .jar which would give more confidence.


----
## Quick wins
* Reformat codebase according to SportRadar coding standards. A Maven plugin can enforce these standards at build time.
* Remove any unused code.
* Remove any commented-out code as it's always available in Git history.
* Chase down all IntelliJ code analysis issues as there are a lot of minor issues such as unused imports, duplicate code fragments etc. which are easily fixed. In most cases, IntelliJ will fix these issues automatically.
* Ensure JavaDoc generation is done on sdk-core module only, or remove altogether as there are 
plenty of JavaDoc TODOs all through the code and it may be way too stale. Better to have
a suite of example projects which customers can use as a springboard.


----
## Nice To Haves

### Updates
- Migrate to JUnit 5.
- Migrate to later Java version (need sufficient tests in place first).
- Update libraries, some like _amqp-client_ are many years old (again need sufficient tests in place first).
- Some libraries like icu4j are only used twice. one to create a Calendar and another for String parsing. I feel like this could be removed.

### Telemetry
Add telemetry (e.g. [MicroMeter](https://micrometer.io/)) so we could have real-time updates from customers. This could be easily configurable too.

Trawling though logfiles is tedious, and the format is different for Java and .NET SDKs. If we could output telemetry in a common format then it would be much easier to interpret/diagnose. This doesn't necessarily have to be logfiles, it could be a proprietary binary format, or perhaps libraries like MicroMeter have a standard we could leverage.

Telemetry would also allow us to track what SDK versions all customers are using.

### Watchdogs
Currently the Watchdog implementations are fixed in what they do. We could have a configurable "recipe" of behaviour which the Watchdog would follow, then we can simulate many varieties of customer. This could be as simple as a .properties file specifying which fields to "get" on each event which arrives to the listener implementation, and even which fields are persisted to database.

Just a thought, but is there a way to have a test setup which runs a Watchdog and then asserts using Grafana queries/metrics? This could verify the Watchdogs performance against SLAs and such.

### BDD Testing
Since there are multiple implementations of the SDK there would be a lot of duplication of work in writing separate tests. 
We could write Java BDD tests which leverage the Fixtures/stubs which already exist so Java/.NET SDKs can be tested against the same scenarios. We could run RabbitMQ using [TestContainers](https://www.testcontainers.org/), use our existing Sports API stubs (both in [WireMock](https://wiremock.org/) and [Undertow](https://undertow.io/)), and could run a dockerized version of either the Java or .NET SDK.

### Eliminate XML Use?
I'm not sure if the Unified Odds Feed and the Sports API only support XML.
But using JSON instead would be much more efficient.
The SDK spends a lot of it's processing marshalling and unmarshalling XML but the customers never see this, so they don't care about the data format and are not tied to XML.


---- 
## General Issues
- The SDK is tied to exactly [Oracle JDK 1.8.0_202](https://www.oracle.com/uk/java/technologies/javase/javase8-archive-downloads.html). Other JDKs have been tried and fail for reasons like Maven plugins not compatible, or JAXB classes not being found in the Java runtime.
- The SDK project builds fine from the command line from the parent package, but fails to build from the **sdk-core** module itself for some reason.
- The SDK has an **sdk-distribution** module which seems to produce a fat .jar containing all of the required dependencies, and uses the Shade Maven plugin to avoid conflicts with customer libraries. But when testing the Watchdogs, a much newer Rabbit client library was copied to the Watchdog deployment and this caused errors. This suggest to me that the SDK is not being built as a fat .jar.


----
# Resources:
* [Unified Feed Swagger](https://iodocs.betradar.com/)
* [Retrofit](https://square.github.io/retrofit/)
* [MicroMeter](https://micrometer.io/)
* [TestContainers](https://www.testcontainers.org/)
* [WireMock](https://wiremock.org/)
* [Undertow](https://undertow.io/)
* [Oracle JDK 1.8.0_202](https://www.oracle.com/uk/java/technologies/javase/javase8-archive-downloads.html)
